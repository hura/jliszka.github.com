TODO

more fun examples
do-notation
more experiment analysis
pgm
beta distribution, entropy
markov chains
k-s test
alias method
stochastic calculus, ito calculus

inside-out functions (selection vs insertion, infer coefficients)
not a monad tutorial


def traffic(carsPerKm: Double, carLength: Double = 10.0): (Double, Double) = {
  val metersBetweenCars = 1000.0 / carsPerKm - carLength
  val secondsBetweenCars = 2.0
  val metersPerSecondToKmPerHour = 3600.0 / 1000.0
  val maxSpeed = math.min(120 - carsPerKm, (metersBetweenCars / secondsBetweenCars) * metersPerSecondToKmPerHour)
  val carsPerHour = carsPerKm * maxSpeed
  (maxSpeed, carsPerHour)
}

def polyFromCoeffs(coeffs: List[Int]): Int => Int = {
  (x: Int) => {
    def eval(cs: List[Int]): Int = {
      cs match {
        case Nil => 0
        case h :: t => h + x * eval(t)
      }
    }
    eval(coeffs)
  }
}

def coeffsFromPoly(p: Int => Int): List[Int] = {
  val x = p(1)
  def uneval(n: Int): List[Int] = {
    n match {
      case 0 => Nil
      case n => (n % x) :: uneval(n / x)
    }
  }
  uneval(p(x))
}



def evalPoly(x: Int, coeffs: List[Int]): (Int, Int) = {
  def eval(cs: List[Int]): Int = {
    cs match {
      case Nil => 0
      case h :: t => h + x * eval(t)
    }
  }
  (x, eval(coeffs))
}

def unevalPoly(x: Int, y: Int): (Int, List[Int]) = {
  def uneval(n: Int): List[Int] = {
    n match {
      case 0 => Nil
      case n => (n % x) :: uneval(n / x)
    }
  }
  (x, uneval(y))
}


def partition(xs: List[A]): (List[A], List[A]) = {
  xs match {
    case Nil => (Nil, Nil)
    case h :: t => {
      (a, b) = partition(t)
      if (h < p) (h :: a, b) else (a, h :: b)
    }
  }
}

def merge(xs: List[A], ys: List[A]): List[A] = {
  (xs, ys) match {
    case ...
    case (x :: xt, y :: yt) => {
      val (a, at, b, bt) = sort2(x, xt, y, yt)
      val bs = b :: bt
      val abs = merge(at, bs)
      a :: abs
    }
  }
}

def extract(xs: List[A]): (List[A], List[A]) = {
  xs match {
    case Nil => (Nil, Nil)
    case h :: t => {
      val (s, r) = extract(t)
      s match {
        case Nil => (h :: Nil, r)
        case sh :: st => {
          if (h < sh) (h :: sh :: st, r) else (sh :: st, h :: r)
        }
      }
    }
  }
}

def extract(xs: List[A]): (List[A], List[A]) = {
  xs match {
    case Nil => (Nil, Nil)
    case a :: abs => {
      val (bs, at) = extract(abs)
      bs match {
        case ... =>
        case b :: bt => {
          (x, xt, y, yt) = sort2(a, at, b, bt)
          (x :: xt, y :: yt)
        }
      }
    }
  }
}



def strand(xs: List[A]): List[A] = {
  val (s, r) = extract(xs)
  merge(s, strand(r))
}

